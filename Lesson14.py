# Алгоритмы на Python 3. Лекция №14.
# лектор: Хирьянов Тимофей Фёдорович
'''
Темы, рассмотренные на лекции №14:
- Тип list. Изменяемость списка.
- Тип кортежа tuple как замороженный список. Насколько не изменяем кортеж?
- Список кортежей и цикл for с двумя переменными.
- Тип строк str. Неизменяемость строки. Методы строки find, count, replace.
- Срезы строк и списков.
- Присваивание в срез списка.
- Стандартные функции len, max, min, sum.
- Методы split и join.
- Структура данных Куча/Пирамида (Heap)
'''

# Тип list

A = [x, y, z]
A = [True, 2, 5.3, "Hello"]

# у значения 'x' будет разный тип данных на разных итерациях
for x in A:
    print(type(x))
'''OUT:
<class 'bool'>
<class 'int'>
<class 'float'>
<class 'str'>
'''

# tuple = кортеж
# Кортеж - это "замороженный" список.
B = (True, 2, 5.3, [])
print(type(B)) # OUT: <class 'tuple'>

# Кортеж - неизменяемый тип данных
A = [True, 2, 5.3, "Hello"]
B = (True, 2, 5.3, A)
A[0] = False
# программа поменяет True на False
print(A) # OUT: [False, 2, 5.3, 'Hello']
# значения кортежа 'B'' не поменяются, а поменяются данные у объекта, на который ссылается 'B', т.е. у объекта 'A'
print(B) # OUT: (True, 2, 5.3, [False, 2, 5.3, 'Hello'])

# !!! Лучше погружать кортежи в списки.

# возьмем список точек
A = [(1, 5), (-3, 4), (-7, 2), (8, 3), (0, 0)]
# распаковка кортежем переменных 'x' и 'y' по списку кортежей
for x, y in A: # x-первое число во всех кортежах, y-второе число во всех кортежах
    print(x, y)


# Строки в Python

s = "Hello"
x = s.find("lo")
print(x) # OUT: 3

# второй способ напечатать то же самое
print(s.find("lo")) # OUT: 3

# Понятно почему - s[0] = 'H', s[1] = 'e', s[2] = 'l', s[3] = 'l', s[4] = 'o',
# то есть подстрока 'lo' начинается с 3го символа.

# многострочная строка (содержит переводы строки \n)
s = """Мой дядя
самых честных
правил."""
print(s) 

# то же самое через перевод строки
s = "Мой дядя\nсамых честных\nправил."
print(s)

# в этом случае происходит экраниование апострофа I\'am
s = 'I\'am a student'

# Количество вхождений символа в строку
s = "Hello"
x = s.count("l")
print(x) # OUT: 2

# Количество вхождений символа в строку (ищем подстроку)
s = "AAAAAA"
x = s.count("AAA")
print(x) # OUT: 2

# Строка - неизменяемый тип данных. Связано с хранением данных строки в кодировке "utf-8" 
s = "AAAAAA"
# созданный объект строки остается неизменным
s.replace("AAA", "BB")
print(s) # OUT: AAAAAA

# Метод строки .replace() создает срез строки, который можно присвоить в переменную (создать новую строку)
x = s.replace("AAA", "BB")
print(x) # OUT: BBBB


# Срезы строк.
# ОБЩИЙ ПРИНЦИП СРЕЗОВ [start:stop:step]

s = "Hello"
# строка 's' состоит из 5 символов
print(len(s)) # OUT: 5

# символы строки            H  e  l  l  o
# индексы строки            0  1  2  3  4
# минусовые индексы строки -1 -2 -3 -4 -5
print(s[4]) # OUT: о

# вывести на печать ell (срезает с 1 по 4 индесы НЕ включительно)
s = "Hello"
s1 = s[1:4]
print(s1) # OUT: ell

# вывести на печать Hlo
s = "Hello"
s1 = s[0:5:2]
print(s1) # OUT: Hlo

# вывести на печать Hello (срезает строку от начала до конца).
s = "Hello"
s1 = s[:]
print(s1) # OUT: Hello


# Срез списка

A = [0, 1, 2, 3, 4]
A1 = A[:]
print(A1) # OUT: [0,1,2,3,4]

# A и A1 - разные списки. Полный срез списка - это создание нового списка.
# Лексикографическое сравнение - элементы должны равняться друг другу.
print(A == A1) # OUT: True
print(A is A1) # OUT: False

# вывести на печать aceghfdb
A = "abcdefgh"
A1 = A
A1 = A[::2] + A[::-2] # "aceg" + "hfdb"
print(A1) # OUT: aceghfdb

# вывести на печать [10, 20, 30, 3, 4]
A = [0, 1, 2, 3, 4]
A[0:3] = [10, 20, 30]
print(A) # OUT: [10, 20, 30, 3, 4]

# вывести на печать [0, 3, 4]
A = [0, 1, 2, 3, 4]
A[0:3] = [0]
print(A) # OUT: [0, 3, 4]

# удаление куска списка
A = [0, 1, 2, 3, 4]
A[0:3] = []
print(A) # OUT: [3, 4]

# вывести на печать []. Пустой срез (за границами списка)
A = [0, 1, 2, 3, 4]
A = A[1000:2000]
print(A) # OUT: []

# вывести на печать [10, 1, 20, 3, 30]
A = [0, 1, 2, 3, 4]
A[::2] = [10, 20, 30]
print(A) # OUT: [10, 1, 20, 3, 30]

# ошибка с шагом
A = [0, 1, 2, 3, 4]
A[::2] = [10, 20, 30, 40]
print(A) # OUT: ValueError: attempt to assign sequence of size 4 to extended slice of size 3

# вывести на печать [4, 1, 2, 3, 0]
A = [0, 1, 2, 3, 4]
A[::2] = A[::-2]
print(A) # OUT: [4, 1, 2, 3, 0]
# !!! приведенная выше операция не является алгоритмичеки правильной, поскольу она потребляет
# значительно больше памяти, нежели сделать то же самое зеркалирование через цикл for !!!


# Несколько стандартных функций списка чисел

#1) Поиск длины списка - len()
A = [0, 1, 2, 3, 4]
print(len(A)) # OUT: 5

#2) Поиск суммы списка - sum()
A = [0, 1, 2, 3, 4]
s = sum(A)
print(s) # OUT: 10

#3) Поиск макс/мин значения в списке - max()/min()
A = [0, 1, 2, 3, 4]
s = max(A)
print(s) # OUT: 4
s = min(A)
print(s) # OUT: 0


# Несколько стандартных функций списка строк
s = input("ФИО: ") # в input вводим Иванов Иван Иваноич

#1) Функция .split() преобразует все символы в элементы списка по разделителю
A = s.split('-')
print(A) # OUT: ['Иванов Иван Иваноич']

#2) Функция .upper() преобразует все символы с большей буквы
A[0] = A[0].upper()
print(A) # OUT: [ИВАНОВ], [ИВАН], [ИВАНОВИЧ]

#3) Функция .lower() преобразует все символы с маленькой буквы
A[0] = A[0].lower()
print(A) # OUT: [иванов], [иван], [иваноич]

#4) Функция .join() преобразует спиок в тект через разделитель, например '-'
A = '-'.join(A)
print(A) # OUT: Иванов Иван Иваноич


# Структура данных Heap (куча или пирамида).

# Особенность <<Heap>>:
# Основана на эффективной нерекурентной сортировке.

# Max Heap
# Данная структура похожа на игру "Цаь горы". Старший символ (самый большой) забираеся на верх горы, а
# самые младшие символы находятся в основании горы

# В Min Heap все наоборот (сверху вниз от меньшего к большему).

# индексы специфичеки связаны друг с дугом:
parent = (i-1) % 2
# где parent - родитель текущего звена (кого нужно спихивать с горы)
# а, i - текущее звено
child1 = i*2 + 1
child2 = i*2 + 2
# где child - дочерний индекс, i - текущий

# БИНАРНАЯ КУЧА.
# Если построение кучи начинается с передачи ключей в виде списка целиком, то кучу можно построить за O(N)
# Если построение кучи происходит методом последовательного добавления ключа, то за O(N log N)
class BinHeap:
    '''Бинарная куча.
    Создание полного двоичного дерева'''
    def __init__(self):
        self.heapList = [0] # не используется, необходим для целочисленного деления, применяемого в последующих методах
        self.currentSize = 0 # текущий размер кучи


    def percUp(self, i):
        '''Поднять новый элемент настолько высоко, насколько
        это требуется для поддержки свойства кучи'''
        while i // 2 > 0:
          if self.heapList[i] < self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2


    def insert(self, k):
        '''Добавить элемент. Присоединить его к концу списка.
        Сравненить новый элемент с его предком. После сравнения
        поменять их местами по средством метода percUp'''
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)


    def percDown(self, i):
        '''Спустить новый элемент настолько низко, насколько
        это требуется для поддержки свойства кучи'''
        while (i * 2) <= self.currentSize:
            mc = self.minChild(i)
            if self.heapList[i] > self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc


    def minChild(self, i):
        '''Получить дочерний индекс'''
        if i * 2 + 1 > self.currentSize:
            return i * 2
        else:
            if self.heapList[i*2] < self.heapList[i*2+1]:
                return i * 2
            else:
                return i * 2 + 1


    def delMin(self):
        '''Удалить корневой элемент.
        Спускать корневой элемент на его правильную позицию'''
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval


    def buildHeap(self, alist):
        '''Постоить кучу'''
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i > 0):
            self.percDown(i)
            i = i - 1


# run TEST_1
print("TEST_1")

# список узлов
nodes = [7, 5, 3, 4, 1, 6, 2]

# init()
A = BinHeap()

# постоть кучу
A.buildHeap(nodes)

# удалить корневой узел
print(A.delMin()) # OUT: 1
print(A.delMin()) # OUT: 2
print(A.delMin()) # OUT: 3
print(A.delMin()) # OUT: 4
print(A.delMin()) # OUT: 5
print(A.delMin()) # OUT: 6
print(A.delMin()) # OUT: 7

# Функция delMin() возвращает корневой элемент с индексом 1, поскольку в конструкторе кучи использовался 0
# в пустой куче остется элемент ноль, функция delMin() не может удалить элемент с индексом 1
# print(A.delMin()) # OUT: IndexError: list index out of range


# run TEST_2. Постоим кучу методом последовательной передачи узлов.
print("TEST_2")

# список узлов
node1 = [7]

# узлы для передачи в метод insert()
node2, node3, node4, node5, node6, node7 = 5, 3, 4, 1, 6, 2

# init()
A = BinHeap()

# постоть кучу
A.buildHeap(node1)

# добавить узлы
A.insert(node2)
A.insert(node3)
A.insert(node4)
A.insert(node5)
A.insert(node6)
A.insert(node7)

# удалить корневой узел
print(A.delMin()) # OUT: 1
print(A.delMin()) # OUT: 2
print(A.delMin()) # OUT: 3
print(A.delMin()) # OUT: 4
print(A.delMin()) # OUT: 5
print(A.delMin()) # OUT: 6
print(A.delMin()) # OUT: 7
