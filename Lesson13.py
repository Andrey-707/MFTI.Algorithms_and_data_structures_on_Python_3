# Алгоритмы на Python 3. Лекция №№13.
# лектор: Хирьянов Тимофей Фёдорович
'''
Темы, рассмотренные на лекции №13:
- Стек
- Автоматическое тестирование функций модуля (библиотека doctest)
- Проверка корректности скобочной последовательности
- Обратная Польская нотация
'''

# Струкуры данных. Стек или <<очередь LIFO>>.

# Очередь называется 'stack'
# Две базовые оперции для работы со стеком - push (затолкнуть) и pop (вытолкнуть)
# Операция size - узнать размер стека (сколько всего сейчас)
# Операция top - узнать верхушку стека
# Операция is_empty - пуст ли стек? True/False

"""Модуль, описывающий структуру данных - стек
>>> clear()
>>> is_empty()
True
>>> push(1)
>>> push(2)
>>> push(3)
>>> is_empty()
False
>>> pop()
3
>>> pop()
2
>>> pop()
1
>>> is_empty()
True
"""

# Реализация A_stack: на массиве (списке) 'list'. ИСПОЛЬЗУЕТСЯ НИЖЕ
# Реализация B_stack: на односвязном списке

_stack = []
def push(x):
    '''
    Добавляет элемент x в конец стека
    
    >>> size = len(_stack)
    >>> push(5)
    >>> len(_stack) - size
    1
    >>> _stack[-1] # check top of stack
    5
    '''
    _stack.append(x)


def pop():
    '''
    Удаляет элемент из спска, при этом
    возвращает сам элемент
    '''
    x = _stack.pop()
    return x


def clear():
    '''
    Очищает стэк
    '''
    _stack.clear()


def is_empty():
    '''
    Проверяет стек пуст или нет.
    Возвращает логическое значение
    '''
    return len(_stack) == 0 # True/False


# run
if __name__ == "__main__":
    import doctest
    doctest.testmod(verbose=True) # verbose=True - подробное описание тестирования
    # doctest.testmod(verbose=False) # малчаливое тестирование (ни чего не выводит, если в коде не допущена ошибка)

# ^
# Записать (сохранить) в файл A_stack.py


# Проверка корректности скобочной последовательности.

# Пустое скобочное выражение: A = ""
# Корректное скобочное выражение: B = (A)
# (())() - корректное
# ())(() - некорректное (при том, что кол-во открытых скобок раное кол-ву закрытых)
# Любые даа корректных скобочных выражения, записанных рядом: C = AB
# Корректное скобочное выражение: B = [A]
# ([])([]) - корректное
# ([)]([]) - некорректное (при том, что кол-во открытых скобок раное кол-ву закрытых)

def match(a, b):
    '''Проверка на совпадение'''
    if (a == '(' and b == ')') or (a == '[' and b == ']'):
        return True
    else:
        return False


def corr(s):
    '''Проверка строки на корректность'''
    x = []
    for i in s:
        if i == '(' or i == '[':
            x.append(i)
        elif len(x) == 0:
            print("некорректно")
            return
        else:
             if not match(x.pop(), i):
                print("некорректно")
                return
    if len(x) == 0:
        print("корректно")
        return
    else:
        print("некорректно")
        return


# run
s = "([])([])"
corr(s) # OUT: корректно
s = "([)]([])"
corr(s) # OUT: некорректно


# doctest Проверка корректности скобочной последовательности.
import A_stack


def is_braces_sequence_correct(s: str):
    '''
    Проверяет корректность скобочной последовательности
    из круглых и кадратных [] скобок ()
    >>> is_braces_sequence_correct("(([()]))[]")
    True
    >>> is_braces_sequence_correct("([)]")
    False
    >>> is_braces_sequence_correct("(")
    False
    >>> is_braces_sequence_correct("]")
    False
    '''
    for brace in s:
        if brace not in "()[]": # является ли скобкой
            continue
        if brace in "([":
            A_stack.push(brace)
        else:
            assert brace in ")]", "Ожидалась закрывающая скобка: " + str(brace)
            if A_stack.is_empty():
                return False
            left = A_stack.pop()
            assert left in "([", "Ожидалась открывающая скобка: " + str(brace)
            if left == "(":
                right = ")"
            elif left == "[":
                right = "]"
            if right != brace:
                return False

    # часть кода:

    # if A_stack.is_empty():
    #     return True
    # else:
    #     False
    
    # можно сократить и записать в одну строчку:

    return A_stack.is_empty()


# run
if __name__ == "__main__":
    import doctest
    # doctest.testmod(verbose=True) # verbose=True - подробное описание тестирования
    doctest.testmod(verbose=False) # малчаливое тестирование (ни чего не выводит, если в коде не допущена ошибка)


# Обраная польская нотация (запись).
'''
Это алгоритм вычисления арифметических выражений в постфиксной записи.
5 + 2 == [5, 2, '+']
(2 + 7) * 5 == [2, 7, '+', 5, '*']
2 + 7 * 5 == [2, 7, 5, '*', '+']

Для каждого токена:
    Если токен - число
        то кладем его в стек
    Иначе - он операция
        y = pop()
        x = pop()
        вычисляем z = x операция y
        push(z)
result = pop()


# ###########
Нам понадобится стек для переменных типа char, т.к. исходное выражение мы получаем в виде строки.

Рассматриваем поочередно каждый символ:
1. Если этот символ - число (или переменная), то просто помещаем его в выходную строку.
2. Если символ - знак операции (+, -, *, / ), то проверяем приоритет данной операции. Операции умножения
и деления имеют наивысший приоритет (допустим он равен 3). Операции сложения и вычитания имеют меньший
приоритет (равен 2). Наименьший приоритет (равен 1) имеет открывающая скобка.
Получив один из этих символов, мы должны проверить стек:
а) Если стек все еще пуст, или находящиеся в нем символы (а находится в нем могут только знаки операций и
открывающая скобка) имеют меньший приоритет, чем приоритет текущего символа, то помещаем текущий символ в
стек.
б) Если символ, находящийся на вершине стека имеет приоритет, больший или равный приоритету текущего
символа, то извлекаем символы из стека в выходную строку до тех пор, пока выполняется это условие; затем
переходим к пункту а).
3. Если текущий символ - открывающая скобка, то помещаем ее в стек.
4. Если текущий символ - закрывающая скобка, то извлекаем символы из стека в выходную строку до тех пор,
пока не встретим в стеке открывающую скобку (т.е. символ с приоритетом, равным 1), которую следует просто
уничтожить. Закрывающая скобка также уничтожается.

Если вся входная строка разобрана, а в стеке еще остаются знаки операций, извлекаем их из стека в выходную
строку.

Дано выражение:
a + ( b - c ) * d

Получить конечный результат:
a b c - d * +

--------------------------------------------------------------------------------------------------------------------
Символ  | Действие                                   |   Состояние выходной строки     |  Состояние стека 
        |                                            |   после совершенного действия   |  после совершенного действия
--------------------------------------------------------------------------------------------------------------------
a       |'a' - переменная. Помещаем еев выходную     |                                 |
        |строку                                      |   a                             |  пуст
--------------------------------------------------------------------------------------------------------------------
+       |'+' - знак операции. Помещаем его в         |                                 |
        |стек (поскольку стек пуст, приоритеты       |                                 |
        |можно не проверять)                         |   a                             |  +
--------------------------------------------------------------------------------------------------------------------
(       |'(' - открывающая скобка. Помещаем в        |                                 |
        |стек.                                       |   a                             |  + (
--------------------------------------------------------------------------------------------------------------------
b       |'b' - переменная. Помещаем ее в выходную    |                                 |
        |строку                                      |   a b                           |  + (
--------------------------------------------------------------------------------------------------------------------
-       |'-' - знак операции, который имеет          |                                 |
        |приоритет 2. Проверяем стек: на вершине     |                                 |
        |находится символ '(', приоритет которого    |                                 |
        |равен 1. Следовательно мы должны просто     |                                 |
        |поместить текущий символ '-' в стек.        |   a b                           |  + ( -
--------------------------------------------------------------------------------------------------------------------
c       |'c' - переменная. Помещаем ее в выходную    |                                 |
        |строку                                      |   a b c                         |  + ( -
--------------------------------------------------------------------------------------------------------------------
)       |')' - закрывающая скобка. Извлекаем из      |                                 |
        |стека в выходную строку все символы, пока   |                                 |
        |не встретим открывающую скобку. Затем       |                                 |
        |уничтожаем обе скобки.                      |   a b c -                       |  +
--------------------------------------------------------------------------------------------------------------------
*       |'*' - знак операции, который имеет          |                                 |
        |приоритет 3. Проверяем стек: на вершине     |                                 |
        |находится символ '+', приоритет которого    |                                 |
        |равен 2, т.е. меньший, чем приоритет        |                                 |
        |текущего символа '*'. Следовательно мы      |                                 |
        |должны просто поместить текущий символ '*'  |                                 |
        |в стек.                                     |   a b c -                       |  + *
--------------------------------------------------------------------------------------------------------------------
d       |'d' - переменная. Помещаем ее в выходную    |                                 |
        |строку                                      |   a b c - d                     |  + *
'''

def reversed_polish_notation(expr: str):
    '''Функция превращения выражения в вид обратной польской нотации'''
    result = [] # здесь хранятся символы
    stack = [] # здесь хранятся знаки операций и открывающая скобка
    oper = ["+", "-", "*", "/", "^", "(", ")"]

    for element in expr:
        if element != " ":
            if element == "(":
                stack = [element] + stack
            elif element in oper:
                if stack == []:
                    stack = [element]
                elif element == ")":
                    while True:
                        q = stack[0]
                        stack = stack[1:]
                        if q == "(":
                            break
                        result += [q]
                elif priority(stack[0]) < priority(element):
                    stack = [element] + stack
                else:
                    while True:
                        if stack == []:
                            break
                        q = stack[0]
                        result += [q]
                        stack = stack[1:]
                        if priority(q) == priority(element):
                            break
                    stack = [element] + stack
            else:
                result += [element]
    while stack != []:
        q = stack[0]
        result += [q]
        stack = stack[1:]
    return " ".join(result)


def priority(value: str):
    '''Вычисление приоритета для конкретной арифметических операций'''
    for k, v in PRIORITY.items():
        if value in v:
            return k
    return -1


# Возможные приоритеты арифметических операций (не все, но этого достаточно для примера).
PRIORITY = {1: ["("], 2: ["+", "-"], 3: ["*", "/"], 4: ["^"]}


# run
expr = "a + ( b - c ) * d"
print(reversed_polish_notation(expr)) # OUT: a b c - d * +

expr = "3 + 2"
print(reversed_polish_notation(expr)) # OUT: 3 2 +

expr = "5 * 2 + 10"
print(reversed_polish_notation(expr)) # OUT: 5 2 * 1 0 +

expr = "3 + 4 * 2 / (1 - 5) ^ 2"
print(reversed_polish_notation(expr)) # OUT: 3 4 2 * 1 5 - 2 ^ / +
