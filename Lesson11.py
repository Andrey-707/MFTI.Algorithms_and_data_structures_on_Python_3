# Алгоритмы на Python 3. Лекция №11.
# лектор: Хирьянов Тимофей Фёдорович
'''
Темы, рассмотренные на лекции №11:
- Двумерное динамическое программирование.
- Наибольшая общая подпоследовательность.
- Наибольшая возрастающая подпоследовательность.
'''

# Двумерное динамическое программирование.

# Задача_1. Шахматная фигура "Король".

# На шахманой доске размерами от 1 до N по вертикали и от 1 до M по горизонтали в ячейке
# 1:1 (в начале) стоит фигура "Король". Требуется узнать солькими способами фигура может добраться
# до ячейки M:N, с условием, что она может ходить на +1 ячейку в сторону или вниз.

'''Решение.
K(NM) - количетво способов достич клетки с координатами (N, M)
Ось с координатами от 1 до M назовем j, ось с координатами от 1 до N назовем i
Итак, количество способов равно: Kij = K(i-1)j + Ki(j-1)
Существуе три способа обхода клеток:
1) Сверху вниз построчно слева направо. Это рекурсия. Очень много вызовов функции (итераций).
2) Слева направо постолбчато сверху вниз. Это тоже рекурсия. Очень много вызовов функции (итераций).
3) По горизонтали и ветикали параллельно. Это динамическое програмирование.
Такой способ вычисления значиельно бысрее рекурсии.
K[i][j] = K[i-1][j] + K[i][j-1]
'''

# Задача_1.1. Шахматная фигура "Король".

# Требуется определить, бьёт ли "Король", стоящий на клетке с указанными координатами (номер строки и столбца),
# фигуру, стоящую на другой указанной клетке за ОДИН ход..
# Входные данные:
# Вводятся четыре числа: координаты "Короля" и координаты другой фигуры. Координаты - целые числа в интервале
# от 1 до 8
# Выходные данные:
# Требуется вывести слово "YES", если "Король" может побить фигуру за 1 ход, в противном случае вывести "NO"


'''Решение:
Король может ходить вверх вниз, вправо влево и по диагонали только на одну клетку. Т.е. если разность между
координатами X и Y будет составлять 1 или -1 (в случае если переходит с меньшей координаты на большую) или
разность одной из координат равна 0 то соответственно король может перейти с первой клетки на вторую.'''
from rich import print


def chess_board(x, y):
    '''Функция ограничивает значения по горизонтали (x) и вертикали (y)
    от 1 включительно до 8 включительно'''
    assert 1 <= x <= 8 and 1 <= y <= 8, "Размеры шахматной доски 8 на 8 клеток."
    return x, y

# фигура "Король" стоит на клетке (x=6:y=4)
x1 = int(input("Введите координаты 'Короля' по горизонтали\n")) # 6
y1 = int(input("Введите координаты 'Короля' по вертикали\n")) # 4

# проверка координат фигуры "Король" на вылет за допустимые границы доски
chess_board(x1, y1)

# фигура 'X' стоит на клетке (x=6:N=y)
x2 = int(input("Введите координаты 'Шахматной фигуры' по горизонтали\n")) # 6
y2 = int(input("Введите координаты 'Шахматной фигуры' по вертикали\n")) # 7

# проверка координат фигуры 'X' на вылет за допустимые границы доски
chess_board(x2, y2)

if  x1 != x2 or y1 != y2:
    # проверка(сравнение) на изменение (дельты) координат на превышение значения в единицу
    # изменение (дэльта) координат по оси x и по оси y не больше 1
    if abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1:
        print("[bold green]YES[/]")
    else:
        print("[bold red]NO[/]")
else:
	print("[bold red]Фигуры не могут стоять на одной клетке[/]")


# Наибольшая общая подпоследовательность.

#Задача_2.
# 'A' и 'B' - одномерные массивы чисел. len(A) == N, len(B) == M
# Требуется узнать какая у них максимальная общая подпоследовательность?

'''Решение:
Подпоследовательность 'A' - это список 'C', содержащий элемены 'A' в исходном порядке, но,
возможно, не все.
Пустая последовательность [] является любой подпоследовательносью последовательности 'A'.
Fij - длина наибольшей возможной подпоследовательности частей 'A' и 'B'.
A[0:i] - Часть 'A', первые i элементов
B[0:j] - Часть 'B', первые j элементов
Итак, вычислим Fij для двух случаев:

1) Два последних элемента равны друг другу ai = bj
ai = [a1, a2, ..., ai-1, ai]
bj = [b1, b2, ..., bj-1, bj]
Fij = 1 + F(i-1)(j-1)

2) Два последних элемента НЕ равны друг другу ai != bj
Fij = max(Fi(j-1), F(i-1)j)
'''

# Реализация функции.
def lcs(A, B): # eng. - largest common subsiquence
	'''Наибольшая общая подпоследовательность'''
	F = [[0]*(len(B) + 1) for i in range(len(A) + 1)] # память зарезервирована нулями
	for i in range(1, len(A) + 1):
		for j in range(1, len(B) + 1):
			if A[i-1] == B[j-1]:
				F[i][j] = 1 + F[i-1][j-1]
			else:
				F[i][j] = max(F[i-1][j], F[i][j-1])
	return F[-1][-1] # -1 означает последний элемент, т.е. F[len(A), len(B)]

# Поиск ВСЕХ различных НОП.
def lcs(A, B):
    '''Наибольшая общая подпоследовательность'''
    F = [[0]*(len(B) + 1) for i in range(len(A) + 1)]
    for i in range(1, len(A) + 1):
        for j in range(1, len(B) + 1):
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])

    sequenceLength = F[-1][-1]  # F[len(A), len(B)]
    sequence = [0]*sequenceLength 
    counter = sequenceLength - 1 
    allSequences = [] 
   
    def trace_all_sequences(A, B, sequence, counter):
    	'''Отслеживать все последовательности'''
        sequence = sequence[:] 
        if counter == -1: 
            allSequences.append(sequence)
            return

        i, j = len(A), len(B) 
        maxx = F[i][j]
        while maxx in F[i] and i > 0:
            if (not maxx in F[i-1]) or (F[i].index(maxx) != F[i-1].index(maxx)):
                sequence[counter] = A[i-1]
                trace_all_sequences(A[:i-1], B[:F[i].index(maxx) - 1], sequence, counter - 1)
            i -= 1
                            
    trace_all_sequences(A, B, sequence, counter)
    return allSequences


# test
A = [3, 2, 1, 4, 5]
B = [1, 2, 3, 5, 4]
print(lcs(A, B)) # OUT: [[1, 5], [2, 5], [3, 5], [1, 4], [2, 4], [3, 4]]


# Наибольшая возростающая подпоследовательность.

'''Fi - наибольшая возрастающая подпоследовательность части A[0:i], которая заканчиваеся
и содержит элемент ai = A[i-1]
Последовательность [a1, a2, ..., ai-1, ai] больше, чем [a1, a2, ..., aj]
Fi = max(Fj) + 1, если i > j and ai > aj
Пустая подпоследовательнось F0 = 0
Для списка 'A' [4, 3, 2, 1] НОП будет равна 1.
'''

# Реализация функции.
def gis1(A):
    '''Возвращает длину наибольшей возрастающей подпоследовательности'''
    F = [0]*(len(A) + 1)
    for i in range(1, len(A) + 1):
        m = 0 # m - текущий максимум
        for j in range(0, i):
            if A[i-1] > A[j-1] and F[j] > m:
                m = F[j]
        F[i] = m + 1
    return F[len(A)] # <=> max(*F)


# test
A = [3, 2, 1, 4, 5, 2, 3, 4, 5, 6]
print(gis1(A)) # OUT: 6


# ... ее можно упростить:
def gis2(A):
    '''Возвращает длину наибольшей возрастающей подпоследовательности'''
    F = [0]*(len(A))
    for i in range(len(A)):
        for j in range(i):
            if A[j] < A[i] and F[j] > F[i]:
                F[i] = F[j]
        F[i] += 1
    return max(*F) # <=> F[len(A)]


# test
A = [3, 2, 1, 4, 5, 2, 3, 4, 5, 6]
print(gis2(A)) # OUT: 6


# Поиск длины наибольшей возрастающей подпоследовательность, начиная с ЕДИНИЦЫ.
def gis3(A):
    F = [0] * len(A)
    F[0] = 1
    for i in range(1, len(A)):
        maximum = 0
        for j in range(i):
            if A[i] > A[j] and F[j] > maximum:
                maximum = F[j]
        F[i] = maximum + 1
    return max(F)


# test
tests = [
    [1, 2, 5, 3, 1, 4, 1],
    [4, 3, 2, 1]
]

for test in tests:
    print(test, "Длина НОП =", gis3(test))
'''OUT:
[1, 2, 5, 3, 1, 4, 1] Длина НОП = 4
[4, 3, 2, 1] Длина НОП = 1
'''


# Алгоритм "укладки рюкзака" (дискретный). Динамическое программирование. O(N*M)

# У каждого предмета есть свой параметр, например для одного предмета v1 , m1 и для другого v2, m2 
# и т.д. vn, mn
# где: v1, v2, ..., vn - стоимось предметов (value)
#      m1, m2, ..., mn - масса предметов (mass)
# M - максимальный вес предметов, который можно уложить в рюкзак
# Вопрос: Какую максимальную стоимость предметов вы можете унести (maxValue) ?

'''Асимптотика решений:
1) Полный перебор О(2**N)
2) Жадный способ O(N**2)
3) Динамическое программирование O(N*M)
'''

# Решение:
'''Есть два варианта наших действий:
1) Берем предмет.    Получаем стоимость:  vn + Y рублей
2) НЕ берем предмет. Получаем стоимость:  X рублей
V = max(X, vn + Y), где V - maxValue = Максимальная стоимость

Решение третьим методом: Расчитать F[i][k]
F[i][k] - максимальная стоимость предметов, которую можно уложить в рюкзак емкости k,
при этом можно ипользовать первые i предметов.
i = [0,1,2,3,4,...,j(i-1), ji, j(i+1)] - строка предметов (количество)
k = [0,1,2,3,4,...,m(k-1), mk, m(k+1)] - столбец массы
F[i][k] = 
1) Берем предмет.    Получаем стоимость:  v[i] + F(k-m[i], i-1)
2) НЕ берем предмет. Получаем стоимость:  F(k, i-1)
F[i][k] = max(v[i] + F(k-m[i], i-1), F(k, i-1))
'''

# m[i] - массы, v[i] - соимости
F = [[0]*(N+1) for i in range(M+1)]
for i in range(1, N+1):
	for k in range(1, M+1):
		if m[i] <= k:
			F[k][i] = max(F[k][i-1], v[i] + F[k-m[i]][i-1])
		else:
			F[k][i] = F[k][i-1]
