# Алгоритмы на Python 3. Лекция №7.
# лектор: Хирьянов Тимофей Фёдорович
'''
Темы, рассмотренные на лекции №7:
- Рекурсия.
- Сказка "Репка" и изготовление матрёшки.
- Прямой и обратный ход рекурсии.
- Фрактальный квадрат в квадрате.
- Факториал числа.
- Алгоритм Евклида.
- Быстрое возведение в степень.
- Ханойские башни.
'''

# Рекурсия.
# сделаем матрешку из 5 частей
def matryoshka(n):
	if n == 1: # крайний случай
		print("Матрёшечка")
	else:
		print("Верх матрешки n=", n)
		matryoshka(n-1)
		print("Низ матрешки n=", n)

matryoshka(5)
'''OUT:
Верх матрешки n= 5
Верх матрешки n= 4
Верх матрешки n= 3
Верх матрешки n= 2
Матрёшечка
Низ матрешки n= 2
Низ матрешки n= 3
Низ матрешки n= 4
Низ матрешки n= 5
'''

# Геометрическая фигура 'квадраты в квадрате' методом рекурсии.
import graphics as gr


window = gr.GraphWin("Graphics", 600, 600)
alpha = 0.2

def fractal_rectangle(A, B, C, D, deep=10):
	'''Фрактальный прямоугольник'''
	if deep < 1: # крайний случай
		return
	for M, N in (A, B), (B, C), (C, D), (D, A):
		gr.Line(gr.Point(*M), gr.Point(*N)).draw(window)
	A1 = (A[0]*(1-alpha) + B[0]*alpha, A[1]*(1-alpha) + B[1]*alpha)
	B1 = (B[0]*(1-alpha) + C[0]*alpha, B[1]*(1-alpha) + C[1]*alpha)
	C1 = (C[0]*(1-alpha) + D[0]*alpha, C[1]*(1-alpha) + D[1]*alpha)
	D1 = (D[0]*(1-alpha) + A[0]*alpha, D[1]*(1-alpha) + A[1]*alpha)
	fractal_rectangle(A1, B1, C1, D1, deep-1)

fractal_rectangle((100, 100), (500, 100), (500, 500), (100, 500))


# Факториал числа 'n' методом рекурсии..
def f(n:int):
	'''Поиск факториала числа "n"'''
	assert n >= 0, "Факториал отрицательного не определен"
	
	if n == 0: # крайний случай
		return 1
	return f(n-1)*n

print(f(int(input()))) # в input() передаем целое положительное число для расчета факториала


# Алгоритм Евклида (случай, когда отрезок 'a' на немного больше орезка 'b')
# Алгоритм Евклида — эффективный алгоритм для нахождения наибольшего общего делителя двух
# целых чисел (или общей меры двух отрезков).
def gcd(a, b): # greatest common divisor
	'''Алгоритм Евклида'''
	if a == b: # крайний случай
		return a
	elif a > b:
		return gcd(a-b, b)
	else: # a < b:
		return gcd(a, b-a)
		
# Алгоритм Евклида (случай, когда из отрезка 'a' нужно вычитать 'b' много-много раз)
def gcd(a, b):
	'''Алгоритм Евклида'''
	if b == 0: # крайний случай
		return a
	else:
		return gcd(b, a % b)

# данный случай можно записать немного короче
def gcd(a, b):
	'''Алгоритм Евклида'''
	return a if b == 0 else gcd(b, a % b)
	

# Быстрое возведение в сепень.
def pow(a:float, n:int):
	'''Быстрое возведение в сепень'''
	if n == 0: # крайний случай
		return 1
	else:
		return pow(a, n-1)*a

# с разделением на четное и нечетное 'n'
def pow(a:float, n:int):
	'''Быстрое возведение в сепень'''
	if n == 0: # крайний случай
		return 1
	elif n % 2 == 1: # для n нечетного
		return pow(a, n-1)*a
	else: # для n четного
		return pow(a**2, n//2)


# Ханойские башни. O(2**N)
# Требуется переставить все диски со стержня 'A'  на стержень 'B', используя вспомогательный
# стержень 'C'. При перекладывании необходимо соблюдать два строгих условия. Во-первых, зараз
# можно перемещать только один диск. Во-вторых, нельзя класть больший диск  поверх меньшего.
def towers_of_hanoi(n, A, B, C):
    '''Ханойские башни'''
    if n <= 1: # крайний случай
        print(f"Перемещаем диск {n} с '{A}' на '{B}'")
        return
    towers_of_hanoi(n-1, A, C, B)
    print(f"Перемещаем диск {n} с '{A}' на '{B}'")
    towers_of_hanoi(n-1, C, B, A)


towers_of_hanoi(3, "A", "B", "C")
