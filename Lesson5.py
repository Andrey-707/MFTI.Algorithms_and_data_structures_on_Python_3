# Алгоритмы на Python 3. Лекция №5.
# лектор: Хирьянов Тимофей Фёдорович
'''
Темы, рассмотренные на лекции №5:
- Список как массив данных.
- Линейный поиск в массиве.
- Копирование массива. Копирование задом-наперёд.
- Алгоритм обращения массива.
- Алгоритм циклического сдвига в массиве.
- Добавление элемента в конец и в начало массива.
- Удаление элемента из конца и начала массива.
- Ссылочная модель данных в Python. Изменяемость списка.
- Решето Эратосфена.
'''

# Массивы (тип list)
A = [1, 2, 3, 4, 5]
# вывести на экран список и тип данных переменной 'A'
print(A, type(A)) # OUT: [1, 2, 3, 4, 5] <class 'list'>

for x in A: # временная переменная x не является числом, а ссылается на число
    print(x, type(x)) # OUT: ЧИСЛО <class 'int'>

for x in A: # временная переменная x не является числом, а ссылается на число
    print(x+1, type(x)) # OUT: ЧИСЛО_увеличенное_на_единицу <class 'int'>

# ЧИСЛА int ИЛИ float В python ЯВЛЯЮТСЯ НЕИЗМЕНЯЕМЫМИ
# при этом сам список не изменяется
print(A, type(A)) # OUT: [1, 2, 3, 4, 5] <class 'list'>

# индексы массива
A = [1, 2, 3, 4, 5]
# i  0  1  2  3  4
# i -5 -4 -3 -2 -1
for x in range(5):
    A[x] = A[x] * A[x]
    print(A[x], type(A[x])) # OUT: ЧИСЛО_умноженное_само_на_себя <class 'int'>


# Заполнение массива 'A'.
A = [0] * 10
print(A) # OUT: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

top = 0 # вершина
x = int(input("Число: ")) # в 'x' с каждой итерацией передаем числа от 10 до 0 (если массив состоит из 10 элементов)
while x != 0: # цикл завершается когда 'x' становится нулем
    A[top] = x
    top += 1
    x = int(input("Число: ")) # в 'x' с каждой итерацией передаем числа от 10 до 0 (если массив состоит из 10 элементов)

print(A) # OUT: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]


# Вывод данных из массива 'A'.
for i in range(4, -1, -1): # проход от 4 до нулевого индекса включительно (обратный ход)
    print(A[i])


# Копирование массива.
N = int(input("Размер массива: ")) # Размер массива целое положительно число
A = [0] * N
B = [0] * N

# заполнение массива 'A' с клавиатуры
for i in range(N):
    A[i] = int(input())

# заполнение массива 'B' элементами массива 'A'
for i in range(N):
    B[i] = A[i]

C = A # объект 'C' ссылается на объект 'A', при этом он не является копией объекта 'A'
A[0] = 777
# первый элемент массива 'C' станет равным 777 (он будет ссылаться на A[0], который равен 777)
print(C[0]) # OUT: 777

# Копирование списка
C = list(A) # список 'C' станет копией списка 'A'

# изменяем значение первого элемента списка 'A', при это список 'C' не изменится
A[0] = 1
print(A) # OUT: [1, 2, 3, 4, 5]
print(C) # OUT: [777, 2, 3, 4, 5]


# Поиск элемента в массиве
def array_search(A:list, N:int, x:int):
    '''Осуществляет поиск числа "x" в массиве "A" от
    нулевого до N-1 индекса включительно.
    Возвращает индекс элемента "X" в массиве "A"
    или -1, если такого нет.
    Если в массиве несколько одинаковых элементов, то
    ввернуть индекс первого по счету.'''
    for i in range(N):
        if A[i] == x:
            return i
    return -1

def test_array_search():
    '''Функция тестирования'''
    # test1
    A1 = [1, 2, 3, 4, 5]
    m = array_search(A1, 5, 8)
    if m == -1:
        print("#test1 - OK")
    else:
        print("#test1 - Fail")
    # test2
    A2 = [-1, -2, -3, -4, -5]
    m = array_search(A2, 5, -3)
    if m == 2:
        print("#test2 - OK")
    else:
        print("#test2 - Fail")
    # test3
    A3 = [10, 20, 30, 10, 10]
    m = array_search(A3, 5, 10)
    if m == 0:
        print("#test3 - OK")
    else:
        print("#test3 - Fail")

# run
test_array_search()
'''OUT:
#test1 - OK
#test2 - OK
#test3 - OK
'''

# Обращение массива.
def invert_array(A:list, N:int):
    '''Обращение массива (разворачивание задом наперед)
    в рамках индексов от 0 до N-1'''
    for i in range(N//2): # чтобы сработал обмен переменными нужно остановиться на середине массива (поэтому N//2)
        # A[i] = A[N-1-i] # такое присваивание не сработает
        A[i], A[N-1-i] = A[N-1-i], A[i] # используем обмен двух переменных


def test_invert_array():
    '''Функция тестирования'''
    # test1
    A1 = [1, 2, 3, 4, 5]
    # print(A1)
    invert_array(A1, 5)
    # print(A1)
    A1_inv = [5, 4, 3, 2, 1]
    if A1 == A1_inv:
        print("#test1 - OK")
    else:
        print("#test1 - Fail")
    # test2
    A2 = [0, 0, 0, 0, 0, 10]
    # print(A2)
    invert_array(A2, 6)
    # print(A2)
    A2_inv = [10, 0, 0, 0, 0, 0] 
    if A2 == A2_inv:
        print("#test2 - OK")
    else:
        print("#test2 - Fail")

# run
test_invert_array()
'''OUT:
#test1 - OK
#test2 - OK
'''

# Циклический сдвиг массива.

# сдвиг влево

# Дан массив 'A', состоящий из N элементов
N = int(input("Число элементов массива: "))
A = list(range(N))

print(A) # OUT: [0, 1, 2, 3, 4]

# сдвигаем массив
tmp = A[0]
for i in range(N-1):
    A[i] = A[i+1]
A[N-1] = tmp

# результат сдвига влево
print(A) # OUT: [1, 2, 3, 4, 0]

# сдвиг вправо

# Дан массив 'B', состоящий из N элементов
N = int(input("Число элементов массива: "))
B = list(range(N))

print(B) # OUT: [0, 1, 2, 3, 4]

# сдвигаем массив
tmp = B[N-1]
for i in range(N-2, -1, -1):
    B[i+1] = B[i]
B[0] = tmp

# результат сдвига вправо
print(B) # OUT: [4, 0, 1, 2, 3]


# Решето Эратосфена.
# По мере прохождения списка нужные (простые) числа остаются, а ненужные (составные) исключаются.

# Логический тип данных является неизвеняемым, поэтому элементы массива ссылаются на него, а не
# являюся им.
N = int(input("Число элементов массива: "))
A = [True] * N # допускаем, что все числа простые (True)

# первые два элемента (число 0 и 1) не считаем (программа выведет их как составные)
A[0] = A[1] = False

for i in range(2, N):
    if A[i]: # if A[i] == True:
        for j in range(2*i, N, i):
            A[j] = False

# На выходе: все простые числа от 2 до n
for i in range(N):
    if i == 0 or i == 1: # не выводить первые два элемента (число 0 и 1)
        pass
    else:
        print(i, "-", "простое" if A[i] else "составное")
